/**
 * Listing Service for AWS Amplify GraphQL
 * 
 * This service handles room listing operations using AWS AppSync GraphQL API.
 * It maintains the same interface as the Vue Supabase listing service.
 */

import { generateClient, type GraphQLResult } from 'aws-amplify/api';
import { getCurrentUser } from 'aws-amplify/auth';
import storageService from './storageService';

import type {
  RoomListing,
  CreateListingData,
  UpdateListingData,
  ListingFilters,
  ListingsResponse,
  ListingServiceInterface,
  Favorite
} from '../types/listing';

// GraphQL queries and mutations (these would normally be generated by Amplify CLI)
const LIST_ROOMS = /* GraphQL */ `
  query ListRooms($filter: ModelRoomFilterInput, $limit: Int, $nextToken: String) {
    listRooms(filter: $filter, limit: $limit, nextToken: $nextToken) {
      items {
        id
        userId
        title
        description
        price
        roomType
        city
        location
        address
        amenities
        images
        mainImageIndex
        isAvailable
        availableFrom
        genderPreference
        religionPreference
        petFriendly
        createdAt
        updatedAt
      }
      nextToken
    }
  }
`;

const GET_ROOM = /* GraphQL */ `
  query GetRoom($id: ID!) {
    getRoom(id: $id) {
      id
      userId
      title
      description
      price
      roomType
      city
      location
      address
      amenities
      images
      mainImageIndex
      isAvailable
      availableFrom
      genderPreference
      religionPreference
      petFriendly
      createdAt
      updatedAt
    }
  }
`;

const CREATE_ROOM = /* GraphQL */ `
  mutation CreateRoom($input: CreateRoomInput!) {
    createRoom(input: $input) {
      id
      userId
      title
      description
      price
      roomType
      city
      location
      address
      amenities
      images
      mainImageIndex
      isAvailable
      availableFrom
      genderPreference
      religionPreference
      petFriendly
      createdAt
      updatedAt
    }
  }
`;

const UPDATE_ROOM = /* GraphQL */ `
  mutation UpdateRoom($input: UpdateRoomInput!) {
    updateRoom(input: $input) {
      id
      userId
      title
      description
      price
      roomType
      city
      location
      address
      amenities
      images
      mainImageIndex
      isAvailable
      availableFrom
      genderPreference
      religionPreference
      petFriendly
      createdAt
      updatedAt
    }
  }
`;

const DELETE_ROOM = /* GraphQL */ `
  mutation DeleteRoom($input: DeleteRoomInput!) {
    deleteRoom(input: $input) {
      id
    }
  }
`;

const SEARCH_ROOMS = /* GraphQL */ `
  query SearchRooms($query: String, $limit: Int, $nextToken: String) {
    searchRooms(query: $query, limit: $limit, nextToken: $nextToken) {
      items {
        id
        userId
        title
        description
        price
        roomType
        city
        location
        address
        amenities
        images
        mainImageIndex
        isAvailable
        availableFrom
        genderPreference
        religionPreference
        petFriendly
        createdAt
        updatedAt
      }
      nextToken
    }
  }
`;

const LIST_FAVORITES = /* GraphQL */ `
  query ListFavorites($filter: ModelFavoriteFilterInput, $limit: Int, $nextToken: String) {
    listFavorites(filter: $filter, limit: $limit, nextToken: $nextToken) {
      items {
        id
        userId
        roomId
        createdAt
        room {
          id
          title
          price
          city
          images
          mainImageIndex
          isAvailable
        }
      }
      nextToken
    }
  }
`;

const CREATE_FAVORITE = /* GraphQL */ `
  mutation CreateFavorite($input: CreateFavoriteInput!) {
    createFavorite(input: $input) {
      id
      userId
      roomId
      createdAt
    }
  }
`;

const DELETE_FAVORITE = /* GraphQL */ `
  mutation DeleteFavorite($input: DeleteFavoriteInput!) {
    deleteFavorite(input: $input) {
      id
    }
  }
`;

/**
 * Listing Service Class
 */
export class ListingService implements ListingServiceInterface {
  private client = generateClient();

  /**
   * Get current authenticated user
   */
  private async getCurrentUserId(): Promise<string> {
    try {
      const user = await getCurrentUser();
      return user.userId;
    } catch (error) {
      throw new Error('User must be authenticated');
    }
  }

  /**
   * Get paginated listings with filters
   */
  async getListings(params: ListingFilters & { page?: number; limit?: number; nextToken?: string } = {}): Promise<ListingsResponse> {
    try {
      const variables: any = {
        limit: params.limit || 10,
        nextToken: params.nextToken
      };

      // Build filter based on parameters
      const filter: any = {};
      
      // Always filter for available properties
      filter.isAvailable = { eq: true };

      if (params.city) {
        filter.city = { eq: params.city };
      }

      if (params.roomType) {
        filter.roomType = { eq: params.roomType };
      }

      if (params.minPrice || params.maxPrice) {
        filter.price = {};
        if (params.minPrice) filter.price.ge = params.minPrice;
        if (params.maxPrice) filter.price.le = params.maxPrice;
      }

      if (params.gender) {
        filter.or = [
          { genderPreference: { eq: params.gender } },
          { genderPreference: { eq: 'any' } }
        ];
      }

      if (params.religion) {
        filter.religionPreference = { eq: params.religion };
      }

      if (params.isPetFriendly) {
        filter.petFriendly = { eq: true };
      }

      if (params.availableFrom) {
        filter.availableFrom = { ge: params.availableFrom };
      }

      // Add amenities filter
      if (params.amenities && params.amenities.length > 0) {
        // This would need to be implemented as a custom resolver
        // For now, we'll apply it after fetching
      }

      if (Object.keys(filter).length > 1) { // More than just isAvailable
        variables.filter = filter;
      }

      const result: GraphQLResult<any> = await this.client.graphql({
        query: LIST_ROOMS,
        variables
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to fetch listings');
      }

      let listings = result.data?.listRooms?.items || [];

      // Apply amenities filter in memory if needed
      if (params.amenities && params.amenities.length > 0) {
        listings = listings.filter((listing: any) => {
          if (!listing.amenities) return false;
          return params.amenities!.some(amenity => 
            listing.amenities.includes(amenity.toLowerCase())
          );
        });
      }

      // Apply search query filter if provided
      if (params.searchQuery) {
        const query = params.searchQuery.toLowerCase();
        listings = listings.filter((listing: any) => 
          listing.title?.toLowerCase().includes(query) ||
          listing.description?.toLowerCase().includes(query) ||
          listing.location?.toLowerCase().includes(query) ||
          listing.city?.toLowerCase().includes(query)
        );
      }

      // Apply sorting
      if (params.orderBy) {
        const direction = params.orderDir || 'asc';
        listings.sort((a: any, b: any) => {
          let aVal = a[params.orderBy!];
          let bVal = b[params.orderBy!];
          
          if (typeof aVal === 'string') {
            aVal = aVal.toLowerCase();
            bVal = bVal.toLowerCase();
          }
          
          if (direction === 'desc') {
            return bVal > aVal ? 1 : -1;
          }
          return aVal > bVal ? 1 : -1;
        });
      }

      return {
        data: this.mapListingsFromGraphQL(listings),
        nextToken: result.data?.listRooms?.nextToken,
        meta: {
          page: params.page || 1,
          limit: params.limit || 10,
          total: listings.length
        }
      };
    } catch (error: any) {
      console.error('Error fetching listings:', error);
      throw new Error(error.message || 'Failed to fetch listings');
    }
  }

  /**
   * Get listing by ID
   */
  async getListingById(id: string): Promise<RoomListing> {
    try {
      const result: GraphQLResult<any> = await this.client.graphql({
        query: GET_ROOM,
        variables: { id }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to fetch listing');
      }

      const room = result.data?.getRoom;
      if (!room) {
        throw new Error('Listing not found');
      }

      return this.mapListingFromGraphQL(room);
    } catch (error: any) {
      console.error('Error fetching listing by ID:', error);
      throw new Error(error.message || 'Failed to fetch listing');
    }
  }

  /**
   * Get featured listings
   */
  async getFeaturedListings(): Promise<RoomListing[]> {
    try {
      const result = await this.getListings({ limit: 6 });
      return result.data;
    } catch (error: any) {
      console.error('Error fetching featured listings:', error);
      throw new Error(error.message || 'Failed to fetch featured listings');
    }
  }

  /**
   * Search listings
   */
  async searchListings(query: string): Promise<RoomListing[]> {
    try {
      // Use the search resolver if available, otherwise filter in memory
      const result: GraphQLResult<any> = await this.client.graphql({
        query: SEARCH_ROOMS,
        variables: { query, limit: 50 }
      });

      if (result.errors) {
        // Fallback to regular listing search with query filter
        const listings = await this.getListings({ searchQuery: query, limit: 50 });
        return listings.data;
      }

      return this.mapListingsFromGraphQL(result.data?.searchRooms?.items || []);
    } catch (error: any) {
      console.error('Error searching listings:', error);
      throw new Error(error.message || 'Failed to search listings');
    }
  }

  /**
   * Get user's listings
   */
  async getMyListings(): Promise<RoomListing[]> {
    try {
      const userId = await this.getCurrentUserId();
      
      const result: GraphQLResult<any> = await this.client.graphql({
        query: LIST_ROOMS,
        variables: {
          filter: {
            userId: { eq: userId }
          },
          limit: 100
        }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to fetch user listings');
      }

      return this.mapListingsFromGraphQL(result.data?.listRooms?.items || []);
    } catch (error: any) {
      console.error('Error fetching user listings:', error);
      throw new Error(error.message || 'Failed to fetch user listings');
    }
  }

  /**
   * Create new listing
   */
  async createListing(listingData: CreateListingData): Promise<RoomListing> {
    try {
      const userId = await this.getCurrentUserId();

      // Upload images first if any
      let uploadedImages: string[] = [];
      if (listingData.images && listingData.images.length > 0) {
        console.log(`Uploading ${listingData.images.length} images`);
        uploadedImages = await Promise.all(
          listingData.images.map(async (image) => {
            return await storageService.uploadImage(image, undefined, userId);
          })
        );
      }

      // Prepare input for GraphQL
      const input = {
        userId,
        title: listingData.title,
        description: listingData.description,
        price: listingData.price,
        roomType: listingData.roomType,
        city: listingData.city,
        location: listingData.location,
        address: listingData.address,
        amenities: listingData.amenities || [],
        images: uploadedImages,
        mainImageIndex: listingData.mainImageIndex || 0,
        availableFrom: listingData.availableFrom,
        genderPreference: listingData.genderPreference || 'any',
        religionPreference: listingData.religionPreference,
        petFriendly: listingData.petFriendly || false,
        isAvailable: true
      };

      const result: GraphQLResult<any> = await this.client.graphql({
        query: CREATE_ROOM,
        variables: { input }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to create listing');
      }

      const createdRoom = result.data?.createRoom;
      
      // Move images from temp to room folder if room was created successfully
      if (createdRoom && uploadedImages.length > 0) {
        const roomId = createdRoom.id;
        const movedImages: string[] = [];
        
        for (const imageUrl of uploadedImages) {
          try {
            const newUrl = await storageService.moveImageToRoom(imageUrl, userId, roomId);
            movedImages.push(newUrl);
          } catch (error) {
            console.error('Error moving image:', error);
            movedImages.push(imageUrl); // Keep original if move fails
          }
        }

        // Update the listing with new image URLs if any were moved
        if (movedImages.some((url, i) => url !== uploadedImages[i])) {
          await this.client.graphql({
            query: UPDATE_ROOM,
            variables: {
              input: {
                id: roomId,
                images: movedImages
              }
            }
          });
          createdRoom.images = movedImages;
        }
      }

      return this.mapListingFromGraphQL(createdRoom);
    } catch (error: any) {
      console.error('Error creating listing:', error);
      throw new Error(error.message || 'Failed to create listing');
    }
  }

  /**
   * Update existing listing
   */
  async updateListing(id: string, listingData: UpdateListingData): Promise<RoomListing> {
    try {
      const userId = await this.getCurrentUserId();
      
      // Get current listing to check ownership and existing images
      const currentListing = await this.getListingById(id);
      
      if (currentListing.userId !== userId && currentListing.user_id !== userId) {
        throw new Error('You can only update your own listings');
      }

      // Handle image updates
      let finalImages = listingData.existingImages || [];

      // Upload new images if any
      if (listingData.images && listingData.images.length > 0) {
        const newImages = listingData.images.filter(img => img instanceof File);
        if (newImages.length > 0) {
          console.log(`Uploading ${newImages.length} new images`);
          
          const uploadedImages = await Promise.all(
            newImages.map(async (image) => {
              return await storageService.uploadImage(image, id, userId);
            })
          );
          
          finalImages = [...finalImages, ...uploadedImages];
        }
      }

      // Delete removed images
      const currentImages = currentListing.images || [];
      const imagesToDelete = currentImages.filter(img => !finalImages.includes(img));
      
      if (imagesToDelete.length > 0) {
        console.log(`Deleting ${imagesToDelete.length} removed images`);
        await Promise.all(
          imagesToDelete.map(async (imageUrl) => {
            await storageService.deleteImageByUrl(imageUrl);
          })
        );
      }

      // Prepare update input
      const input: any = {
        id,
        images: finalImages,
        mainImageIndex: (listingData.mainImageIndex !== undefined) ? 
          listingData.mainImageIndex : 
          (finalImages.length > 0 ? 0 : undefined)
      };

      // Add other fields to update
      if (listingData.title !== undefined) input.title = listingData.title;
      if (listingData.description !== undefined) input.description = listingData.description;
      if (listingData.price !== undefined) input.price = listingData.price;
      if (listingData.roomType !== undefined) input.roomType = listingData.roomType;
      if (listingData.city !== undefined) input.city = listingData.city;
      if (listingData.location !== undefined) input.location = listingData.location;
      if (listingData.address !== undefined) input.address = listingData.address;
      if (listingData.amenities !== undefined) input.amenities = listingData.amenities;
      if (listingData.availableFrom !== undefined) input.availableFrom = listingData.availableFrom;
      if (listingData.genderPreference !== undefined) input.genderPreference = listingData.genderPreference;
      if (listingData.religionPreference !== undefined) input.religionPreference = listingData.religionPreference;
      if (listingData.petFriendly !== undefined) input.petFriendly = listingData.petFriendly;

      const result: GraphQLResult<any> = await this.client.graphql({
        query: UPDATE_ROOM,
        variables: { input }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to update listing');
      }

      return this.mapListingFromGraphQL(result.data?.updateRoom);
    } catch (error: any) {
      console.error('Error updating listing:', error);
      throw new Error(error.message || 'Failed to update listing');
    }
  }

  /**
   * Delete listing
   */
  async deleteListing(id: string): Promise<boolean> {
    try {
      const userId = await this.getCurrentUserId();
      
      // Get listing to check ownership and delete images
      const listing = await this.getListingById(id);
      
      if (listing.userId !== userId && listing.user_id !== userId) {
        throw new Error('You can only delete your own listings');
      }

      // Delete associated images
      if (listing.images && listing.images.length > 0) {
        console.log(`Deleting ${listing.images.length} images for listing ${id}`);
        await Promise.all(
          listing.images.map(async (imageUrl) => {
            await storageService.deleteImageByUrl(imageUrl);
          })
        );
      }

      // Delete the listing
      const result: GraphQLResult<any> = await this.client.graphql({
        query: DELETE_ROOM,
        variables: { input: { id } }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to delete listing');
      }

      return true;
    } catch (error: any) {
      console.error('Error deleting listing:', error);
      throw new Error(error.message || 'Failed to delete listing');
    }
  }

  /**
   * Toggle listing availability status
   */
  async toggleListingStatus(id: string): Promise<RoomListing> {
    try {
      const userId = await this.getCurrentUserId();
      const listing = await this.getListingById(id);
      
      if (listing.userId !== userId && listing.user_id !== userId) {
        throw new Error('You can only update your own listings');
      }

      const result: GraphQLResult<any> = await this.client.graphql({
        query: UPDATE_ROOM,
        variables: {
          input: {
            id,
            isAvailable: !listing.is_available
          }
        }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to toggle listing status');
      }

      return this.mapListingFromGraphQL(result.data?.updateRoom);
    } catch (error: any) {
      console.error('Error toggling listing status:', error);
      throw new Error(error.message || 'Failed to toggle listing status');
    }
  }

  /**
   * Get related listings
   */
  async getRelatedListings(id: string): Promise<RoomListing[]> {
    try {
      const currentListing = await this.getListingById(id);
      
      const result = await this.getListings({
        city: currentListing.city,
        roomType: currentListing.room_type,
        limit: 4
      });

      // Filter out the current listing
      return result.data.filter(listing => listing.id !== id);
    } catch (error: any) {
      console.error('Error fetching related listings:', error);
      throw new Error(error.message || 'Failed to fetch related listings');
    }
  }

  /**
   * Add listing to favorites
   */
  async addFavorite(roomId: string): Promise<any> {
    try {
      const userId = await this.getCurrentUserId();

      const result: GraphQLResult<any> = await this.client.graphql({
        query: CREATE_FAVORITE,
        variables: {
          input: {
            userId,
            roomId,
            createdAt: new Date().toISOString()
          }
        }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to add favorite');
      }

      return result.data?.createFavorite;
    } catch (error: any) {
      console.error('Error adding favorite:', error);
      throw new Error(error.message || 'Failed to add favorite');
    }
  }

  /**
   * Remove favorite listing
   */
  async removeFavorite(favoriteId: string): Promise<boolean> {
    try {
      const result: GraphQLResult<any> = await this.client.graphql({
        query: DELETE_FAVORITE,
        variables: { input: { id: favoriteId } }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to remove favorite');
      }

      return true;
    } catch (error: any) {
      console.error('Error removing favorite:', error);
      throw new Error(error.message || 'Failed to remove favorite');
    }
  }

  /**
   * Get user's favorite listings
   */
  async getFavorites(): Promise<Favorite[]> {
    try {
      const userId = await this.getCurrentUserId();

      const result: GraphQLResult<any> = await this.client.graphql({
        query: LIST_FAVORITES,
        variables: {
          filter: {
            userId: { eq: userId }
          },
          limit: 100
        }
      });

      if (result.errors) {
        throw new Error(result.errors[0]?.message || 'Failed to fetch favorites');
      }

      return result.data?.listFavorites?.items || [];
    } catch (error: any) {
      console.error('Error fetching favorites:', error);
      throw new Error(error.message || 'Failed to fetch favorites');
    }
  }

  /**
   * Check if listing is favorited
   */
  async isFavorite(roomId: string): Promise<boolean> {
    try {
      const userId = await this.getCurrentUserId();

      const result: GraphQLResult<any> = await this.client.graphql({
        query: LIST_FAVORITES,
        variables: {
          filter: {
            userId: { eq: userId },
            roomId: { eq: roomId }
          },
          limit: 1
        }
      });

      return result.data?.listFavorites?.items?.length > 0;
    } catch (error: any) {
      console.error('Error checking favorite status:', error);
      return false;
    }
  }

  /**
   * Toggle favorite status
   */
  async toggleFavorite(roomId: string): Promise<boolean> {
    try {
      const isFav = await this.isFavorite(roomId);
      
      if (isFav) {
        const favorites = await this.getFavorites();
        const favorite = favorites.find(fav => fav.roomId === roomId);
        if (favorite) {
          await this.removeFavorite(favorite.id);
        }
      } else {
        await this.addFavorite(roomId);
      }

      return true;
    } catch (error: any) {
      console.error('Error toggling favorite:', error);
      throw new Error(error.message || 'Failed to toggle favorite');
    }
  }

  /**
   * Map GraphQL room data to RoomListing interface
   */
  private mapListingFromGraphQL(room: any): RoomListing {
    return {
      id: room.id,
      title: room.title,
      description: room.description,
      city: room.city,
      location: room.location,
      address: room.address,
      room_type: room.roomType,
      price: room.price,
      images: room.images || [],
      main_image_index: room.mainImageIndex || 0,
      gender_preference: room.genderPreference,
      religion_preference: room.religionPreference,
      available_from: room.availableFrom,
      created_at: room.createdAt,
      updated_at: room.updatedAt,
      pet_friendly: room.petFriendly,
      amenities: room.amenities || [],
      is_available: room.isAvailable,
      user_id: room.userId,
      userId: room.userId
    };
  }

  /**
   * Map array of GraphQL room data to RoomListing array
   */
  private mapListingsFromGraphQL(rooms: any[]): RoomListing[] {
    return rooms.map(room => this.mapListingFromGraphQL(room));
  }
}

// Create singleton instance
export const listingService = new ListingService();
export default listingService;